!-----Generates the gradients needed for zeldo for a single realization
!-----of an input matter power spectrum from initspec. For this
!-----realization, it also produces the potential power spectrum and the 
!-----density field power spectrum.

!-----Cleaned-up version for HACC test initializer 
!-----Salman Habib, Feb 18, 2012

!-----This version is for a new IC generator that starts in real space 
!-----rather than in Fourier space by first producing a Gaussian white
!-----noise realization and then filtering it in Fourier space
!-----Salman Habib, March 18, 2012

      subroutine indensRS(ng,rL,psp,gradxv,gradyv,gradzv,hubble,
     #         iseed,pmass,frm,pbchoice,initp,egtldetr,pkinit)

      implicit none

!-----scalars

      integer ii,jj,mm,ng,iseed,np
      integer left,right,dim      
      integer seed_size,clock,ksign,icpy
      integer frm,pbchoice,initp

      real rL,tpiL,rLb
      real rscale,tpi,ns,w,scal,hubble,pmass

      complex imi

!-----arrays

      integer, dimension(:), allocatable :: seed

      real pk(ng/2),pkinit(ng/2)
      real kk(ng)
      real psp(ng,ng,ng),dens(ng,ng,ng),phi(ng,ng,ng)
      real aran(ng,ng,ng),bran(ng,ng,ng)
      real gradx(ng,ng,ng),grady(ng,ng,ng),gradz(ng,ng,ng)
      real gradxv(ng,ng,ng),gradyv(ng,ng,ng),gradzv(ng,ng,ng)
      real lfilt(ng),ree(ng)

      real aranl(ng**3),branl(ng**3)

      complex ee(ng)
      complex egtldetr(ng,ng,ng),dc(ng,ng,ng),dctr(ng,ng,ng)
      complex kdc(ng,ng,ng)

!-----:psp
!-----ramp1,ramp2,phi,gradx,grady,gradz:dens
!-----align/distributes

!hpf$ distribute kk(block)
!hpf$ distribute ee(block)
!hpf$ distribute ree(block)
!hpf$ align (:) with ree(:) :: lfilt
!hpf$ distribute pk(block)
!hpf$ align (:) with pk(:) :: pkinit
!hpf$ distribute aranl(block)
!hpf$ align (:) with aranl(:) :: branl
!hpf$ distribute psp(*,*,block)
!hpf$ distribute dens(*,*,block)
!hpf$ align (*,*,:) with dens(*,*,:) :: phi,gradx,grady,gradz
!hpf$ align (*,*,:) with dens(*,*,:) :: gradxv,gradyv,gradzv
!hpf$ align (*,*,:) with dens(*,*,:) :: aran,bran
!hpf$ distribute dc(*,*,block)
!hpf$ align (*,*,:) with dc(*,*,:) :: kdc
!hpf$ distribute dctr(*,*,block)
!hpf$ distribute egtldetr(*,*,block)

      write(6,*) 'Enter indensRS'

!-----Define constants/initialize

      tpi=8.0*atan(1.0) ! 2 pi
      rLb=ng*1.0        ! Box length converted to real length
      rscale=rL/rLb     ! scaling from box to physical units
      tpiL=tpi/rL       ! k0, physical units

      aran=0.0
      bran=0.0
      psp(1,1,1)=0.0
      dc=(0.0,0.0)
      dctr=(0.0,0.0)      

!-----Begin generation of realization

      call random_seed(SIZE=seed_size)
      allocate (seed(seed_size))
      CALL random_seed(GET=seed(1:seed_size))
      CALL system_clock(COUNT=clock)
      do ii=1,seed_size	
      	 seed(ii)=iseed+(ii-1)*1000
      enddo
      CALL random_seed(PUT=seed(1:seed_size))

!-----Gaussian deviates

      CALL random_number(aran)
      CALL random_number(bran)

      dens=sqrt(-2.0*log(aran))*(cos(tpi*bran))

!-----Zero-shift the random field
 
      dens=dens-sum(dens)/(1.0*ng*ng*ng)

!-----Diagnostic output

      write(6,*) 'maxval of dens =', maxval(dens)
      write(6,*) 'sum(dens)=', sum(dens)

!      do ii=1,ng
!      write(21,*) ii,dens(ng/2,ng/2,ii)
!      enddo
      
!-----Compute power spectrum of the initial realization
!-----in physical units 
!-----pspec1 returns pk

      call pspec1(dens,ng,pk)
      pkinit=pk*rscale**3

      open(unit=31,file='out_pkinit_flat.dat')
      do mm=1,ng/2
      write(31,*) mm*tpiL,pkinit(mm)
      enddo
      close(31)


!-----FFT the density field: dc and dctr are temporary complex arrays
!-----dc is the complexifed initial density, output goes to dctr

      dc=dens

      ksign=1
      scal=1.0
      icpy=0

      call fft3d(ng,ng,ng,ksign,scal,icpy,dc,dctr)

!-----Reuse aran and bran as amplitude and phase of dctr; note 
!-----dctr has to be normalized by the fft sqrt volume factor, 
!-----enforce a zero DC mode
      
      dctr=dctr/ng**1.5
      dctr(1,1,1)=(0.0,0.0)

      aran=abs(dctr)
      bran=acos(real(dctr)/aran)

!-----Multiply dctr by the desired transfer function

      forall(ii=1:ng,jj=1:ng,mm=1:ng)dctr(ii,jj,mm)=
     #      dctr(ii,jj,mm)*sqrt(psp(ii,jj,mm))

!-----Invert the FFT to go back to real space
!-----NOTE: Conventions are such that there is no compensation for
!-----inverse FFT scaling!

      ksign=-1
      scal=1.0
      icpy=0

      call fft3d(ng,ng,ng,ksign,scal,icpy,dctr,dc)

!-----Scale by volume*3/2 factor to get the true density

      dens=real(dc,8)/rL**1.5

!      do ii=1,ng
!      write(65,*) ii,dens(ng/2,ng/2,ii),psp(ng/2,ng/2,ii)
!      enddo

!-----Compute the power spectrum of the initial realization 

      call pspec1(dens,ng,pk)
      pkinit=pk*rscale**3

      open(unit=41,file='out_pkinit.dat')
      do mm=1,ng/2
      write(41,*) mm*tpiL,(pkinit(mm))
      enddo
      close(41)

!-----Solve Poisson equation for `bare' phi
!-----Step I: Fourier transform the mass density
!-----instead of icpy=0, icpy=1 means that the result of fft3d, 
!-----dctr, gets put back in dc. This involves an extra transpose.

!-----Reuse dc and dctr as temporary arrays

      dc=(0.,0.)
      dc=dens

      ksign=1
      scal=1.0
      icpy=0

      call fft3d(ng,ng,ng,ksign,scal,icpy,dc,dctr)

!-----Step II: Convolve the mass density with the Green's function

      dctr=dctr*egtldetr

!-----Step III: Carry out inverse FFT compensating for the scaling

      ksign=-1
      icpy=1

      call fft3d (ng,ng,ng,ksign,scal,icpy,dctr,dc)

      dc=dctr/(1.0*ng*ng*ng)

!-----Step IV: Final result

!-----Diagnostic printout for the potential

!      do ii=1,ng
!      write(23,*) ii,real(dc(ng/2,ng/2,ii)),aimag(dc(ng/2,ng/2,ii))
!      enddo

      phi=real(dc,8)

!-----Get power spectrum of bare potential by calling pspec1

      call pspec1(phi,ng,pk)

      open(unit=43,file='out_pkinit_phi.dat')
      do mm=1,ng/2
      write(43,*) mm*tpiL,(pk(mm))*rscale**3,
     #            pk(mm)*(mm*tpiL)**4*rscale**7
      enddo
      close(43)

!-----Compute the gradient of the potential via FFT, first Fourier 
!-----transform phi(x)

      ksign=1
      scal=1.0
      icpy=1

      call fft3d(ng,ng,ng,ksign,scal,icpy,dc,dctr)

!-----icpy=1 means that the result of fft3d, dctr, gets put back in dc.
!-----This involves an extra transpose. (Historical remark: Set icpy=1 
!-----for now to make the code behave like the original cmf code.)

!-----Define lfilt with its options (L2, L4, L6)

      lfilt=-aimag(ee)
      lfilt(1)=0.0

!-----This piece of code produces the correct one-dimensional k-vector 
!-----in the usual FFT format, ee is -ik and kk is k

      imi=(0.0,1.0)

      forall(ii=1:ng)kk(ii)=(ii-1)*tpi/(1.0*ng)

      do ii=1,ng
      if(ii.ge.ng/2+1)kk(ii)=(ii-ng-1)*tpi/(1.0*ng)
      enddo

      ee=-imi*kk

!-----Symmetrize the k vector (ensures imaginary pieces of the 
!-----derivative are zero to single precision)

      ee(ng/2+1)=(0.0,0.0)

!-----Compute x gradient from k-space potential field.

      forall(ii=1:ng)kdc(ii,:,:)=ee(ii)*dc(ii,:,:)

!-----Go back to real space.

      icpy=1
      ksign=-1
      scal=1.0

      call fft3d (ng,ng,ng,ksign,scal,icpy,kdc,dctr)

!-----Compensation for inverse FFT scaling

      kdc=kdc/(rLb**3)

      gradxv=real(kdc)

!-----Now compute y gradient from original k-space potential field:

      forall(ii=1:ng)kdc(:,ii,:)=ee(ii)*dc(:,ii,:)

!-----Go back to real space.

      icpy=1
      ksign=-1
      scal=1.0

      call fft3d(ng,ng,ng,ksign,scal,icpy,kdc,dctr)

!-----Compensation for inverse FFT scaling

      kdc=kdc/(rLb**3)

      gradyv=real(kdc)

!-----Finally, compute z gradient from original k-space potential 
!-----field:

      forall(ii=1:ng)kdc(:,:,ii)=ee(ii)*dc(:,:,ii)

!-----Go back to real space.

      icpy=1
      ksign=-1
      scal=1.0

      call fft3d(ng,ng,ng,ksign,scal,icpy,kdc,dctr)

!-----Compensation for inverse FFT scaling

      kdc=kdc/(rLb**3)

      gradzv=real(kdc)

      write(6,*) 'Done with indensRS: initial density field generated'
      
      return
      end subroutine








